[{"title":"Dart（Flutter） pub 包管理","url":"/2019/02/21/Dartpub/","content":"\n<hr>\n\nPub（https://pub.dartlang.org/ ）是Google官方的Dart Packages仓库，类似于node中的npm仓库，android中的jcenter，我们可以在上面查找我们需要的包和插件，也可以向pub发布我们的包和插件。我们将在后面的章节中介绍如何向pub发布我们的包和插件。\n\n# 示例\n接下来，我们实现一个显示随机字符串的widget。有一个名为“english_words”的开源软件包，其中包含数千个常用的英文单词以及一些实用功能。我们首先在pub上找到english_words这个包，确定其最新的版本号和是否支持Flutter。\n\n![english_words](http://wx4.sinaimg.cn/large/006ar8zggy1g0duqg9p60j30y105e0ta.jpg)\n\n我们看到“english_words”包最新的版本是3.1.3，并且支持flutter，接下来：\n\n将english_words（3.1.3版本）添加到依赖项列表，如下：\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  cupertino_icons: ^0.1.0\n  # 新添加的依赖\n  english_words: ^3.1.3\n```\n\n### 下载包\n\n在Android Studio的编辑器视图中查看pubspec.yaml时，单击右上角的 Packages get 。\n![Packages get](http://wx4.sinaimg.cn/large/006ar8zggy1g0dur11rqtj30dp0a8ab5.jpg)\n\n这会将依赖包安装到您的项目。您可以在控制台中看到以下内容：\n```\nflutter packages get\nRunning \"flutter packages get\" in flutter_in_action...\nProcess finished with exit code 0\n```\n\n## 使用\n1、引入english_words包\n```dart\nimport 'package:english_words/english_words.dart';\n```\n\n在输入时，导入后该行代码将会显示为灰色，请放心，这并不一定是安装失败导致的。它表示导入的库尚未使用。\n\n![import 'package:english_words/english_words.dart';](http://wx4.sinaimg.cn/large/006ar8zggy1g0dvh5ytdej30hd030t8r.jpg)\n\n2、使用english_words包来生成随机字符串。\n```dart\nclass RandomWordsWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 生成随机字符串\n    final wordPair = new WordPair.random();\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: new Text(wordPair.toString()),\n    );\n  }\n}\n```\n3、我们将 RandomWordsWidget 添加到\"计数器\"示例的首页MyHomePage 的Column的子widget中。\n\n![RandomWordsWidget](http://wx4.sinaimg.cn/large/006ar8zggy1g0dvh87tibj30oy0oktay.jpg)\n\n![RandomWordsWidget](http://wx4.sinaimg.cn/large/006ar8zggy1g0dvhap38oj30cr0mstai.jpg)\n\n## 热更新\n\n如果应用程序正在运行，请使用热重载按钮【⚡】更新正在运行的应用程序。每次单击热重载或保存项目时，都会在正在运行的应用程序中随机选择不同的单词对。 这是因为单词对是在 build 方法内部生成的。每次热更新时，build方法都会被执行。\n\n![⚡](http://wx4.sinaimg.cn/large/006ar8zggy1g0dvhib782j30nx02bq2x.jpg)\n","tags":["Dart","Flutter","pub"],"categories":["Dart","Flutter"]},{"title":"Dart for the web  一小时入门","url":"/2019/02/20/DartWeb/","content":"\n<hr>\n\n官方网站：https://webdev.dartlang.org/guides/get-started\n\n#### 1、Dart-window 安装\nhttp://www.gekorm.com/dart-windows/\n\n#### 2、安装开发工具 webstorm\nhttps://webdev.dartlang.org/tools/webstorm\n\n#### 3、安装使用 pub 安装两个必备插件：activate，webdev\n```bash\n> pub global activate webdev\n> pub global activate stagehand\n```\n\n#### 4、新建一个Dart项目\n\n![Create Dart](http://wx3.sinaimg.cn/large/006ar8zggy1g0d0u82axpj30r00gwjsm.jpg)\n\n#### 5、启动应用程序\n\n![Run 'index.html'](http://wx3.sinaimg.cn/large/006ar8zggy1g0d0yt2xluj30ps0m1q5g.jpg)\n\n![Serving `web` on http://localhost:53322](http://wx3.sinaimg.cn/large/006ar8zggy1g0d0yuv7wqj30k207d74n.jpg)\n\n![Your Dart app is running.](http://wx3.sinaimg.cn/large/006ar8zggy1g0d0ywnt0lj313n04zaa8.jpg)","tags":["Dart"],"categories":["Dart"]},{"title":"在 Windows 上搭建 Flutter 开发环境","url":"/2019/02/20/在Windows上搭建Flutter开发环境/","content":"\n<hr>\n1、获取Flutter SDK：https://flutter.io/sdk-archive/#windows\n\n2、解压 **flutter_windows_v1.0.0-stable.zip**，并将 flutter/bin 加入到环境变量\n\n3、安装Android Studio ：https://developer.android.google.cn\n\n4、在 Android Studio 的 **Browse repositories** 安装 **Flutter** 和 **Dart** 插件\n- Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。\n- Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。\n\n欢迎页 -> configure -> Plugins -> Browse repositories... -> Search\n\n![configure](http://wx4.sinaimg.cn/large/006ar8zggy1g0cy57wy3qj30mr0ng3zw.jpg)\n\n![Plugins](http://wx4.sinaimg.cn/large/006ar8zggy1g0cy5amfb5j30ru0nttac.jpg)\n\n![Browse repositories...](http://wx4.sinaimg.cn/large/006ar8zggy1g0cy5d3o4xj30so0o20v9.jpg)\n\n5、安装完 flutter 插件后，重启一下Android Studio，然后我们就可以新建 flutter 模板了。\n\n欢迎页 -> Start a new Flutter project -> Flutter application -> 输入项目名称和选择flutter的sdk目录 -> finish\n\n![Start a new Flutter project](http://wx4.sinaimg.cn/large/006ar8zggy1g0cyaijpcwj30mu0i3q3y.jpg)\n\n![Flutter application](http://wx4.sinaimg.cn/large/006ar8zggy1g0cyie6pehj30ru0nn3zo.jpg)\n\n![flutter sdk ](http://wx4.sinaimg.cn/large/006ar8zggy1g0cyigbo29j30ru0nn75k.jpg)\n\n![finish](http://wx4.sinaimg.cn/large/006ar8zggy1g0cyij36rtj30ru0nnjsk.jpg)\n\n6、运行应用程序\n\n![Flutter Demo Home Page](http://wx4.sinaimg.cn/large/006ar8zggy1g0cyqjwvnkj313n0q7wka.jpg)\n\n---\n\n可能遇到的问题：\n##### 0. 任何访问不了网站，自动安装失败、下载失败等网络问题，自己想办法搞vpn fq。\n\n- [阿里云 香港服务器 Centos7 3分钟搞定vpn](https://www.cnblogs.com/CyLee/p/10401766.html)\n\n- [加速度](https://dc.36fy.com/)\n\n##### 1. 启动Android Studio时，出现“Unable to access Android SDK add-on list”\n点击 **\"Cancel\"**， 稍后再根据指引，自动安装即可。\n\n##### 2. 其他常见配置问题\n[https://book.flutterchina.club/chapter1/configuration.html](https://book.flutterchina.club/chapter1/configuration.html)","tags":["flutter"],"categories":["flutter"]},{"title":"阿里云 香港服务器 Centos7 3分钟搞定vpn","url":"/2019/02/19/aliyun/","content":"\n<hr>\n\n\n教程传送门：\n[阿里云主机搭建VPN服务](https://blog.csdn.net/ztx114/article/details/80423705)\n[在免费EC2上搭建自己的VPN](https://my.oschina.net/imcf/blog/659230)\n\n#### 1、安装python 和 Pip\n```\n$ yum install python-setuptools && easy_install pip -y\n```\n\n#### 2、安装 shadowsocks\n```\n$ pip install shadowsocks\n```\n\n#### 3、添加 shadowsocks 的配置文件\n```\n$ vim /etc/shadowsocks.json\n{\n    \"server\": \"0.0.0.0\",\n    \"server_port\": 443,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n    \"password\": \"daweiyixiangshihao\",\n    \"timeout\": 300,\n    \"method\": \"aes-256-cfb\",\n    \"fast_open\": false,\n    \"workers\": 1\n}\n```\n\n- server_port：是开放端口，阿里云默认开放了443;\n- password：是连接密码;\n- server：就是本机，保持0.0.0.0 即可;\n- method：是传输方式，保持\"aes-256-cfb\" 即可;\n\n#### 4、启动 shadowsocks 服务\n```\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n\n#### 5、本机下载  shadowsocks.exe \n链接：https://pan.baidu.com/s/17y-v40jPGIHcftuE7gGiEA \n提取码：5gzb \n\n#### 6、配置 shadowsocks.exe \n![](aliyun/1.png)\n\n#### 7、访问google.com 测试\n![](aliyun/2.png)\n\n","tags":["centos","aliyun","vpn","shadowsocks"],"categories":["centos","vpn"]},{"title":"《Docker每天五分钟》八：Dockerfile 中的命令三兄贵","url":"/2019/02/11/Docker每天五分钟8/","content":"\n<hr>\n\n# RUN vs CMD vs ENTRYPOINT\n\n简单地说：\n（1）RUN： 该命令会创建一个镜像层，适合在安装软件包的时候使用。\n（2）CMD： 配置容器启动后默认执行的命令及其参数，但 CMD 会被 `$ docker run` 后面跟的命令行参数替换。比如 `$ docker run -it [image] /bash/bin`， 那么 CMD 指令会被忽略掉。\n（3）ENTRYPOINT：配置容器启动时运行的命令。\n\n# RUN\nRUN 指令会创建新的镜像层。 通常用于安装应用和软件包。 Dockerfile 中常常包含多个 RUN 指令。\n\nRUN 有两种格式：\n（1） **Shell 格式（推荐）： `RUN yum update && yum install gcc-c++\\vim\\git -y`**\n（2） Exec 格式： `RUN [\"yum\", \"install\", \"gcc-c++\", \"vim\", \"git\", \"-y\"]`\n\n> 注意，我们反复提到 RUN 指令会创建新的镜像层。镜像层的概念就类似缓存。会在各个地方的dockerfile被反复使用。\n> 这里 yum update 放在和安装同一个指令中。能保证每次安装都是最新的包。如果 yum update 单独的RUN。则会创建一个 yum update 的镜像层。当其他地方的d ockerfile 使用 yum update 的时候，就会直接使用该镜像层，而这一层很可能是很久以前缓存的了。\n\n# CMD\n此命令会在容器启动后运行。 前提是 `$ docker run` 没有指定其他命令。\n- 如果 docker run 指定了其他命令， CMD 指定了默认命令将被忽略。\n- 如果 Docker file 中有多个 CMD 指令，只有最后一个 CMD 有效。\n\nCMD 有三种格式：\n（1） **Exec 格式（推荐）： CMD [\"/bin/echo\", \"Hello World\"]**\n（2） 嫁衣格式： CMD [\"param1\", \"params2\"]\n（3） Shell格式： CMD echo \"Hello World\"\n\n> （2）嫁衣格式是为 ENTRYPOINT 提供参数，此时 ENTRYPOINT 必须使用 Exec 格式。\n\n举例说明 CMD 和 `$ docker run` 的关系，Dockerfile 片段如下：\n\n```dockerfile\nCMD echo \"Hello world\"\n```\n运行容器 `$ docker run -it [image]` 将输出：\n```\nHello world\n```\n但如果加上命令： `$ docker run -it [image] /bin/bash`， CMD 会被忽略掉。也就没有输出 `Hello world` 了\n\n# ENTRYPOINT\n\nENTRYPOINT 指令可以让容器以应用程序或者服务的形式运行。\n\nENTRYPOINT 与 CMD 很相似，它们都可以指定执行的命令和参数。不同的地方在于 ENTRYPOINT 不会被 `$ docker run` 时指定的命令忽略。\n\nENTRYPOINT 有两种格式：\n（1） **Exec 格式（推荐）： ENTRYPOINT [\"executable\", \"param1\", \"param2\"]**\n（2）Shell 格式：ENTRYPOINT command param1 param2\n\n> ENTRYPOINT 不同的格式效果差别巨大。 选择使用时必须小心。\n> ENTRYPOINT 的 Exec 格式可以接受 CMD 或 `$ docker run` 提供的参数。\n> ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 `$ docker run` 提供的参数。\n\n### ENTRYPOINT 的 Exec 格式\n\nENTRYPOINT 的 Exec 格式可以接受 CMD 或 `$ docker run` 提供的参数。 比如下面的 Dockerfile 片段：\n```dockerfile\nENTRYPOINT [\"/bin/echo\", \"Hello\"] CMD [\"world\"]\n```\n当容器通过 `$ docker run -it [image]` （无命令）启动时，输出为：\n```\nHello world\n```\n\n而如果通过 `$ docker run -it [image] CloudMan` 启动时，则输出为：\n```\nHello CloudMan\n```\n\n# Exec 格式 与 变量 shell 解析\n\n> 请注意，当需要解析变量时，应该使用 Shell 解析，如/bin/sh（bash） \n\n例如下面的 Dockerfile 片段，我们用 ENV 指令设置了环境变量 $name 并不会被解析：\n\n```dockerfile\nENV name Cloud Man ENTRYPOINT [\"/bin/echo\", \"Hello, $name\"]\n```\n\n运行容器将输出： \n```shell\nHello, $name\n```\n\n> 注意：环境变量 $name 没有被替换。必须使用 shell 解析。\n\n如果希望使用环境变量，如下修改 Dockerfile：\n```dockerfile\nENV name Cloud Man ENTRYPOINT [\"/bin/sh\", \"-c\", \"echo Hello, $name\"]\n```\n\n运行容器将输出： \n```shell\nHello, Cloud Man\n```","tags":["Docker"],"categories":["Docker"]},{"title":"碎片化经验广场","url":"/2019/02/04/碎片化经验广场/","content":"\n<hr>\n\n### 如何在 dockerhub 找到合适的镜像？\n\n1. 确定你的 base 镜像，如`centos`\n3. 确定你的开发环境和依赖，比如`php + nginx + mysql + redis`\n3. 找到官方镜像仓库\n","tags":["碎片化","经验"],"categories":["碎片化","经验"]},{"title":"《Docker每天五分钟》七：调试 dockerfile","url":"/2019/02/03/Docker每天五分钟7/","content":"\n<hr>\n\n总结一下 `dockerfile` 的构建镜像的过程：\n1. 从 base 镜像运行一个容器。\n2. 执行一条指令，对容器做修改。\n3. 执行类似 `docker commit` 的操作，生成一个新的镜像层。\n4. Docker 再基于刚刚提交的镜像运行一个新容器。\n5. 重复 2 ~ 4 步，直到 `dockerfile` 中所有的指令执行完毕。\n\n从这个过程可以看出，**如果 `dockerfile` 由于某种原因执行到某个指令失败了，我们也能够得到前一个指令成功执行构建出的镜像。**\n\n这样当我们修复完bug再次执行构建的时候，也能依靠docker的缓存特性跳过已完成的镜像。这对开发和调试 `dockerfile` 是非常友好且有帮助的。我们可以通过控制台的打印和测试，快速定位错误和分析原因。\n\n<hr>\n\n我们来看一个调试示例，以 buysbox 为 base 镜像：\n\n> BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件。BusyBox 包含了一些简单的工具，例如ls、cat和echo等等，还包含了一些更大、更复杂的工具，例grep、find、mount以及telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀。\n\n新建一个 `Dockerfile` 和一个测试文件 `testfile`:\n```bash\n[root@10-255-0-217 dc2-user]# echo test > testfile\n[root@10-255-0-217 dc2-user]# vim Dockerfile\n```\nDockerfile 内容如下：\n> FROM busybox\n> RUN touch tmpfile\n> RUN /bin/bash -c echo \"continue to build...\"\n> COPY testfile /\n\n开始构建调试\n```bash\n[root@10-255-0-217 dc2-user]# docker build -t image-debug .\n```\n![/bin/sh: /bin/bash: not found](Docker每天五分钟7/1.png)\n\n我们可以轻松发现在执行第三句指令： `RUN /bin/bash -c echo \"continue to build...\"` 的时候发生了异常，\n\n错误信息是: `/bin/sh: /bin/bash: not found`\n\n很显然我们得知了 buysbox 系统中不包含 /bin/bash 程序。然后再进一步的修正。\n\n<hr>\n\n上述这种错误是比较简单且显而易见的，大部分的bug都是难以肉眼观察，我们希望进一步的调试。\n\n根据 `Dockerfile` 构建镜像的特性，尽管由于某种原因执行到某个指令失败了，我们也能够得到前一个指令成功执行构建出的镜像。\n\n在此例子中，就是由 `RUN touch tmpfile` 指令构成的镜像 `6fa9f3938b8b`：\n\n![RUN touch tmpfile](Docker每天五分钟7/2.png)\n\n我们也可以从 `docker images` 中查看最后成功的镜像：\n\n![docker images](Docker每天五分钟7/3.png)\n\n然后我们进入镜像之中进一步的操作体验和调试：\n```bash\n[root@10-255-0-217 dc2-user]# docker run -it 6fa9f3938b8b\n/ # /bin/bash -c echo \"continue to build...\"\nsh: /bin/bash: not found\n/ # \n```\n\n依然能得出 `/bin/bash: not found` 的错误定位结果。","tags":["Docker"],"categories":["Docker"]},{"title":"《Docker每天五分钟》六：第一个 Dockerfile","url":"/2019/02/02/Docker每天五分钟6/","content":"\n<hr>\n\nDockerfile 是一个文本文件，记录了镜像构建的所有步骤。\n\n```bash\n$ vim Dockerfile\n```\nDockerfile 内容如下：\n\n> FROM centos\n> RUN yum install -y vim\n\n开始构建\n\n```bash\n$ docker build -t centos-with-vim .\n```\n- -t：指明镜像的名字，该示例为 `centos-with-vim`；\n- 请注意最后一个`.` 它指明在当前路径寻找 Dockerfile；\n\n经过漫长的安装之后。我们查看一下镜像列表 `$ docker images`:\n\n![docker images](Docker每天五分钟6/1.png)\n\n### docker 的`缓存`特性：\n\n可以看到 Docker 分为了两个镜像： `centos` 和 `centos-with-vim`。\n\n其中 `centos` 镜像我们称为base镜像。而 `centos-with-vim` 就是基于base镜像构建的。\n\n如果在构建之前你的本地镜像已经存在base镜像。那么会直接使用，无须重新下载和构建。这也是 docker 的重要`缓存`特性。\n","tags":["Docker"],"categories":["Docker"]},{"title":"《Docker每天五分钟》五：docker commit 制作镜像","url":"/2019/02/02/Docker每天五分钟5/","content":"\n<hr>\n\ndocker commit 命令是创建新镜像最直接的方法，其过程包含三个步骤：\n- 运行容器\n- 修改容器\n- 将容器保存为新镜像\n\n###### （1）运行容器\n```bash\n[root@10-255-0-217 dc2-user]# docker run -it centos\n\nUnable to find image 'centos:latest' locally\nlatest: Pulling from library/centos\na02a4930cb5d: Pulling fs layer \nlatest: Pulling from library/centos\na02a4930cb5d: Pull complete \nDigest: sha256:184e5f35598e333bfa7de10d8fb1cebb5ee4df5bc0f970bf2b1e7c7345136426\nStatus: Downloaded newer image for centos:latest\n\n[root@ea9b3dcd88ad /]# \n```\n\n自动下载了最新版本的 Centos 镜像，并且运行和进入了容器（ea9b3dcd88ad）。\n\n###### (2) 修改容器\n\n这里示例安装 vim \n\n```bash\n[root@ea9b3dcd88ad /]# vim\nbash: vim: command not found\n\n[root@ea9b3dcd88ad /]# yum install -y vim\n...\nComplete!\n```\n\n###### (3) 保存为新镜像\n\n让容器继续运行着，然后 `新建窗口` 来查看当前运行的镜像。\n```bash\n[root@10-255-0-217 dc2-user]# docker ps\n```\n![silly_aryabhata](Docker每天五分钟5/1.png)\n\n`silly_aryabhata` 是 Docker 为我们的容器随机分配的名字。\n\n执行 `docker commit` 命令将容器保存为镜像。\n\n```bash\n[root@10-255-0-217 dc2-user]# docker commit silly_aryabhata centos-with-vi\n\nsha256:3badf3a0b2d0a59bd3cd106e70d088c32da2e59676746e7613a30f7eb5d3e2b0\n```\n\n![centos-with-vi](Docker每天五分钟5/2.png)\n\n对比两个镜像，从 `SIZE` 上看到镜像因为安装了 `vim` 软件而变大了。\n\n<hr>\n\n以上演示了如何用 `docker commit` 创建新镜像。\n\n> 然而，Docker 并不建议用户通过 `docker commit` 这种方式构建镜像。\n\n### 原因如下：\n\n1. 这是一种手工创建镜像的方式，容易出错，效率低且重复性弱。比如要在ubuntu镜像中也加入vim，还得重复前面所有步骤。\n2. 使用者并不知道镜像是如何创建出来的，里面提供什么服务，包含什么程序，里面是否有恶意程序？也就是说无法对镜像进行审计，存在安全隐患。\n\n既然 `docker commit` 不是推荐的方法，我们为什么还要花时间学习呢？\n\n> 即便是用 dockerfile（推荐方法）构建镜像，底层也是 `docker commit` 一层一层构建镜像的。学习 `docker commit` 能够帮助我们更加深入的理解构建过程和镜像的分层结构。","tags":["Docker"],"categories":["Docker"]},{"title":"碎片化知识广场","url":"/2019/02/01/碎片化知识广场/","content":"\n<hr>\n\n###### (1) 如何调试 node_modules 中的代码？\n\n如果你尝试直接修改 `node_modules` 中的源码，如加上断点 `debugger;` 或者 打印 `console.log` 是没有效果的。\n\n这是为什么？\n\n这是因为你引用的是它编译好的内容。（通常在目录下 `package.json` 中 `main` 字段指向）。而你修改的是它的源码，并没有实时编译。当然你可以修改源码后重新编译他们，但没什么必要。这样很容易玩崩……_(:3」∠)_\n\n>（仔细想想本来就不可能实时编译 `node_modules` 中所有的依赖。平时开发 `webpack` 热编译的 `src` 下的文件都需要耗费几秒钟了。更不可能去兼顾编译 `node_modules` 中的内容）\n\n正确的做法是：将**入口文件**迁移到项目目录，而入口文件中的其他依赖直接指向 `node_modules` 中的源码目录即可。 \n\n原理是什么? 就像上文说的，`webpack` 热编译的只有 `src` 下的项目，如果你将要调试的文件迁移到你的项目 `src` 中，`webpack` 就能编译了，而入口的依赖文件哪怕指向 `node_modules` 也没关系，`webpack` 也会自动收集并且编译。这样我们就能愉快的在 `node_modules` 中修改源码了。\n\n\n","tags":["cpmposer"],"categories":["cpmposer"]},{"title":"《Docker每天五分钟》四：常用api","url":"/2019/01/31/Docker每天五分钟4/","content":"\n<hr>\n\n\n|\t命令   |\t\t功能      |\n|----------|:------------:|\n| $ docker images |  查看所有镜像 |\n| $ docker ps -a | 查看所有容器   |\n| $ docker run -it <镜像> | 运行本地镜像，如果镜像不存在则下载最新版本  |\n| $ docker exec -it <已启动容器> /bin/bash | 以交互的方式进入已启动的容器内部  |\n| $ docker stop <容器> | 停止容器  |\n| $ docker start <容器> | 启动容器  |\n| $ docker rm <容器> | 删除容器，必须先停止容器 |\n| $ docker rmi <镜像> | 删除镜像，必须先删除所有依赖该镜像的容器 |\n| $ docker build -t <新建容器名> . | 通过 Dockerfile 构建镜像，<br>请注意最后一个`.` 指明在当前路径寻找 Dockerfile |\n| $ docker history <镜像> | 查看镜像的构建层级 |\n\n\n\n> Dockerfile 支持以 ‘#’ 开头注释\n\n\n\n|\t命令   |\t\t功能      |\n|----------|:------------:|\n| FORM | 指定 base 镜像 |\n| MAINTAINER | 设置镜像的作者，可以是任意字符串 |\n| RUN | （命令三兄弟之一）在容器中运行指定命令。 |\n| CMD | （命令三兄弟之一）在容器启动时运行指定的命令。 |\n| ENTRYPOINT | （命令三兄弟之一）设置容器启动时运行的命令。 |\n| COPY | 将文件复制到镜像，`COPY src desc` 与 `COPY [\"src\", \"desc\"]` |\n| ADD | 与COPY类似，将文件复制到镜像。不同的是如果src是归档文件（zip、taz、xz等），文件会被自动解压 |\n| ENV | 设置环境变量，环境变量可被后面的指令使用如： <br> `ENV MY_VERSION 1.9.1 RUN yum install -y mypackage=$MY_VERSION` |\n| WORKDIR | 设置镜像中当前工作目录（服务于COPY、ADD、CMD、RUN、ENTRYPOINT等指令）。 |\n| EXPOSE | 指定容器中的进程会监听某个端口， Docker 可以将该端口暴漏出来。 |\n| VOLUME | 将文件或目录声明为 volume。 |\n\n注意点：\n- Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。\n- Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。\n- CMD 指令会被 `$ docker run [image] ...` 之后的参数替换掉。 如  `$ docker run [image] /bash/bin`\n- CMD 或 docker run 之后的参数会被当做参数传递给ENTRYPOINT。\n\n","tags":["Docker"],"categories":["Docker"]},{"title":"《Docker每天五分钟》三：hello-world、初识dockerfile","url":"/2019/01/31/Docker每天五分钟3/","content":"\n<hr>\n\nhello-world 是 Docker 官方提供的一个镜像。通常用来验证 Docker 是否安装成功。 我们先通过 `$ docker pull` 从 Docker Hub 下载它。\n```bash\n$ docker pull hello-world\n```\n\n使用 `$ docker images` 查看镜像是否下载成功。 发现才不到2kb！ \n\n![Size 1.84kB](Docker每天五分钟3/1.png)\n\n通过 `$ docker run` 运行它。\n\n```bash\n$ docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n```\n\n<hr>\n\nDockerfile 是镜像的描述文件，定义了如何构建 Docker 镜像。\n\n> 注：可以在 [dockerhub](https://hub.docker.com/_/hello-world?tab=description) 中查看 Dockerfile 内容\n\n\n\n","tags":["Docker"],"categories":["Docker"]},{"title":"《Docker每天五分钟》二：切换 DaoCloud 镜像源","url":"/2019/01/31/Docker每天五分钟2/","content":"\n<hr>\n\n切换国内 [DaoCloud](https://dashboard.daocloud.io/settings/profile) 镜像服务。 [免费注册](https://account.daocloud.io/signup)后进入控制台，找到右上角的[加速器图标](https://www.daocloud.io/mirror)。\n\n![加速器](Docker每天五分钟2/3.png)\n\n然后找到Linux的配置命令。\n\n![配置 Docker 加速器](Docker每天五分钟2/1.png)\n\n你的配置命令也许和我的不一样哦。\n\n```bash\n$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io\n\n$ sudo systemctl restart docker\n```\n\n\n\n","tags":["Docker"],"categories":["Docker"]},{"title":"《Docker每天五分钟》一：启动第一个httpd容器","url":"/2019/01/31/Docker每天五分钟1/","content":"\n<hr>\n\n```bash\n$ sudo docker run -d -p 8080:80 httpd\n```\n\n1）从 Docker Hub 下载 httpd 镜像。镜像中已经安装好了 Apache HTTP Server.\n2）启动容器，并将容器的80端口映射到宿主机的8080端口。\n\n这样当我们访问宿主机的8080端口时，就能看到HTTP服务页面了。\n\n> 如果外网ip访问不了。请确保你服务器的安全组，以及本机的防火墙配置。\n\n```bash\n$ curl localhost:8080\n\n<html><body><h1>It works!</h1></body></html>\n```\n\n![It works!](Docker每天五分钟1/2.png)\n\n\n","tags":["Docker"],"categories":["Docker"]},{"title":"Nginx与php结合","url":"/2019/01/25/Nginx与php结合/","content":"\n<hr>\n\n### 传送门：\n- [Centos7 PHP-lastest 安装](/2019/01/25/php安装/)\n- [centos7 nginx 安装](/2019/01/24/nginx安装/)\n\n### 操作预览：\n1. 将 php.ini 文件中的配置项 cgi.fix_pathinfo 设置为 0\n2. 修改 `php-fpm.conf` 路径引用错误的bug\n3. 添加并且修改 `www.conf`\n4. 启动 php-fpm\n5. 配置 Nginx 使其支持 PHP 应用\n6. 配置 .php 文件的请求将被传送到后端的 PHP-FPM 模块\n7. 重启 Nginx。\n8. 创建测试文件\n\n<hr>\n\n> 补充：搭建环境最怕的就是路径不同，建议配合 `$ find / -name \"你要搜索的文件名\"` 来辅助。\n> 建议结合[官网教程](http://php.net/manual/zh/install.unix.php](http://php.net/manual/zh/install.unix.php)使用。\n> 但实际上官网的内容部分也是过时的无效的。所以要结合第三方文章来排坑。\n\n\n###### 1. 将 php.ini 文件中的配置项 cgi.fix_pathinfo 设置为 0\n```bash\n$ vim /usr/local/php/php.ini\n```\n定位到 `cgi.fix_pathinfo` 并将其修改为如下所示：\n\n> cgi.fix_pathinfo=0\n\n###### 2. 修改 `php-fpm.conf` 路径引用错误的bug\n\n```bash\n$ vim /usr/local/etc/php-fpm.conf\n```\n\n找到最后一行 `include=NONE/etc/php-fpm.d/*.conf`，改为 `include=etc/php-fpm.d/*.conf`\n\n> include=NONE/etc/php-fpm.d/*.conf\n> 改为\n> include=etc/php-fpm.d/*.conf\n\n###### 3. 添加 www.conf，并且修改权限\n```bash\n$ cd /usr/local/etc/php-fpm.d\n$ cp www.conf.default www.conf\n$ vim www.conf\n```\n\n找到并修改以下内容：\n\n```bash\n; Unix user/group of processes\n; Note: The user is mandatory. If the group is not set, the default user's group\n;       will be used.\nuser = nobody\ngroup = nobody\n```\n\n###### 4. 启动 php-fpm\n\n```bash\n$ /usr/local/bin/php-fpm\n```\n\n\n###### 5. 配置 Nginx 使其支持 PHP 应用\n\n`$ vim /usr/local/nginx/conf/nginx.conf`，修改默认的 location 块，使其支持 .php 文件：\n\n```nginx\nlocation / {\n    root   html;\n    index  index.php index.html index.htm;\n}\n```\n\n###### 6. 配置 .php 文件的请求将被传送到后端的 PHP-FPM 模块\n```nginx\nlocation ~* \\.php$ {\n    fastcgi_index   index.php;\n    fastcgi_pass    127.0.0.1:9000;\n    include         fastcgi_params;\n    fastcgi_param   SCRIPT_FILENAME    $document_root$fastcgi_script_name;\n    fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;\n}\n```\n\n\n###### 7. 重启 Nginx。\n```bash\n$ sudo /usr/local/nginx/sbin/nginx -s stop\n$ sudo /usr/local/nginx/sbin/nginx\n```\n\n###### 8. 创建测试文件\n```bash\n$ rm /usr/local/nginx/html/index.html\n$ echo \"<?php phpinfo(); ?>\" >> /usr/local/nginx/html/index.php\n```\n\n![php.info](Nginx与php结合/1.png)\n","tags":["nginx","php"],"categories":["nginx"]},{"title":"hexo的认知","url":"/2019/01/25/hexo的认知/","content":"\n<hr>\n\n### 预览：\n1. 自定义文章模板\n2. 加入 `<script>`\n3. 加入全局样式\n4. hexo 内置全局变量\n5. 如何打印全局变量\n6. 本地搜索功能\n7. 部署的git和项目的git\n\n\n#### 1. 自定义文章模板\n> \\themes\\landscape\\layout\\_partial\\after-footer.ejs\n\n#### 2. 加入 `<script>`\n> \\scaffolds\\post.md\n\n#### 3. 加入全局样式\n> \\my\\themes\\landscape\\source\\css\\style.styl\n\n#### 4. hexo 内置全局变量\n> [https://hexo.io/zh-cn/docs/variables](https://hexo.io/zh-cn/docs/variables)\n\n#### 5. 如何打印全局变量\n打开任意一个ejs文件如：`my\\themes\\landscape\\layout\\_partial\\article.ejs`，顶部加入JavaScript代码：\n```ejs\n<% \n\tconsole.log(20190125172431, post) \n%>\n```\n不过并不会打印到页面，而是打印到控制台。\n\n![console.log](hexo的认知/1.png)\n\n#### 6.本地搜索功能\n\n需要结合插件 [hexo-generator-search](https://github.com/wzpan/hexo-generator-search) 来使用：\n\n```bash\n$ cnpm install https://github.com/wzpan/hexo-generator-search\n```\n配置 `_config.yml`\n\n> search:\n>   path: search.json\n>   field: post\n>   content: true\n\n当你使用 `$ hexo g` 之后，publish 目录下就生成了search.json了。我们就可以根据这个json来做本地搜索。\n\n#### 7. 部署的git和项目的git\n\n我们希望部署/publish到github.io和项目本身的git不一样。只需要加入一个 [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git) 插件即可。\n\n```bash\n$ cnpm install hexo-deployer-git\n```\n\n配置 `_config.yml`\n\n```yml\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/dragon8github/dragon8github.github.io.git\n  branch: master\n```\n\n这样我们就可以使用 `$ hexo g && hexo d` 来部署到github.io了。就不会和我们项目本身的git冲突了。","tags":["hexo"],"categories":["hexo"]},{"title":"网页无法播放MP4的解决方案","url":"/2019/01/25/网页无法播放MP4的解决方案/","content":"\n<hr>\n\n### 操作预览：\n1. 下载 `格式工厂`\n2. 选择 MP4 导入你需要转换的视频\n3. 右键列表中的视频选择 `输出配置`，选择 `视频编辑：AVC（H264）`\n4. 点击开始\n\n![网页无法播放MP4的解决方案](/1.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n    #myVideo {\n        position: fixed;\n        left: 0;\n        right: 0;\n        top: 0;\n        z-index: 199307100337;\n    }\n    </style>\n</head>\n\n<body>\n    <video autoplay loop muted id=\"myVideo\">\n        <source src=\"./saber.mp4\" type=\"video/mp4\">\n    </video>\n</body>\n</html>\n```\n\n![saber.mp4](网页无法播放MP4的解决方案/2.png)","tags":["MP4","video","HTML"],"categories":["HTML","video","MP4"]},{"title":"Centos7 PHP-lastest 安装","url":"/2019/01/25/php安装/","content":"\n<hr>\n\n参考官方 UNIX 编译教程： [http://php.net/manual/zh/install.unix.php](http://php.net/manual/zh/install.unix.php)\n\n###### 1、安装依赖\n```bash\n$ sudo yum install libxml2 libxml2-devel\n```\n###### 2、下载php（China）: http://php.net/get/php-7.3.1.tar.gz/from/a/mirror\n```bash\n$ wget -O php-7.3.1.tar.gz http://cn2.php.net/get/php-7.3.1.tar.gz/from/this/mirror\n```\n\n###### 3、编译三兄贵\n```bash\n$ ./configure --disable-fileinfo --enable-fpm\n$ make && make install \n```\n\n加入--disable-fileinfo是为了避免make时出现如下错误：\n> virtual memory exhausted: Cannot allocate memory \n> make: *** [ext/fileinfo/libmagic/apprentice.lo] Error 1\n\n其中 `--enable-fpm` 是支持fpm扩展\n\n安装完成之后，会出现如下提示语：\n\n> Wrote PEAR system config file at: /usr/local/etc/pear.conf\n> You may want to add: /usr/local/lib/php to your php.ini include_path\n> /home/dc2-user/php-7.3.1/build/shtool install -c ext/phar/phar.phar /usr/local/bin\n> ln -s -f phar.phar /usr/local/bin/phar\n> Installing PDO headers:           /usr/local/include/php/ext/pdo/\n\n请放心这是正常的，实际上此时你的php已经安装成功了：\n```bash\n$ php -v\n\nPHP 7.3.1 (cli) (built: Jan 24 2019 21:37:18) ( NTS )\nCopyright (c) 1997-2018 The PHP Group\nZend Engine v3.3.1, Copyright (c) 1998-2018 Zend Technologies\n```\n\n###### 4、创建配置文件，并将其复制到正确的位置。\n```bash\n$ sudo cp php.ini-development /usr/local/php/php.ini\n$ sudo cp /usr/local/etc/php-fpm.conf.default /usr/local/etc/php-fpm.conf\n$ sudo cp sapi/fpm/php-fpm /usr/local/bin\n```\n\n接下来你可能想要了解：\n- [nginx 与 php 结合使用](/2019/01/25/Nginx与php结合/)\n- nginx 与 apache 结合使用","tags":["centos","PHP"],"categories":["centos","PHP"]},{"title":"Centos7 依赖全家桶","url":"/2019/01/24/Centos7依赖全家桶/","content":"\n<hr>\n\n该文收集我安装 Centos7 环境中所有依赖的第三方包。只需要执行以下一句代码即可：\n```bash\n$ sudo yum install \\\ngcc-c++ \\\nzlib-devel \\\npcre-devel \\\nlibxml2 \\\nlibxml2-devel \\\nyum-utilsdevice-mapper-persistent-data \\\nlvm2 \\\nyum-utils \\\nautoconf \\\n```","tags":["centos","yum"],"categories":["centos"]},{"title":"Centos7 Nodejs 安装","url":"/2019/01/24/Nodejs安装/","content":"\n<hr>\n\n### 操作预览\n1. 下载nodejs： https://nodejs.org/en/download/\n2. 检查配置是否健康\n3. make 编译（大概需要半小时）\n4. 安装（root）\n5. 验证\n\n###### 1. 下载nodejs： https://nodejs.org/en/download/\n```bash\n$ wget https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gz\n```\n\n###### 2. 检查配置是否健康\n```bash\n$ ./configure\n```\n\n###### 3. make 编译（大概需要半小时）\n```bash\n$ make\n```\n\n###### 4. 安装（root）\n```bash\n$ sudo make install\n```\n\n###### 5. 验证安装是否成功\n```bash\n$ node -v \nv10.15.0\n```","tags":["centos","Nodejs"],"categories":["centos","Nodejs"]},{"title":"centos7 nginx 安装","url":"/2019/01/24/nginx安装/","content":"\n<hr>\n\n### 操作预览：\n1. 安装依赖\n2. 下载nginx ： http://nginx.org/en/download.html\n3. 解压\n4. 检查配置是否健康\n5. 开始安装\n6. 检查是否安装成功，默认安装目录是在/usr/local/nginx\n7. 启动nginx服务\n8. 查看服务是否开启\n9. 使用 `$ curl localhost` 查看 nginx 欢迎页 \n\n//////////////////////////////////////////////\n\n\n##### 1、安装依赖\n```bash\n$ yum -y install gcc-c++ zlib-devel pcre-devel\n```\n\n##### 2、下载nginx ： http://nginx.org/en/download.html\n```bash\n$ wget http://nginx.org/download/nginx-1.15.8.tar.gz\n```\n\n##### 3、解压\n```bash\n$ tar zxvf nginx-1.15.8.tar.gz\n```\n\n//////////////////////////////////////////////\n\n##### 4、检查配置是否健康\n```bash\n$ ./configure\n```\n\n##### 5、开始安装\n```bash\n$ make && make install\n```\n\n//////////////////////////////////////////////\n\n##### 6、检查是否安装成功，默认安装目录是在/usr/local/nginx\n```bash\n$ /usr/local/nginx/sbin/nginx -t\n\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n\n##### 7、启动nginx服务\n```bash\n$ /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n```\n\n//////////////////////////////////////////////\n\n##### 8、查看服务是否开启\n```bash\n$ ps -ef | grep nginx\n```\n\n##### 9、使用 `$ curl localhost` 查看 nginx 欢迎页 \n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>Welcome to nginx!</h1>\n<p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.</p>\n\n<p>For online documentation and support please refer to\n<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\nCommercial support is available at\n<a href=\"http://nginx.com/\">nginx.com</a>.</p>\n\n<p><em>Thank you for using nginx.</em></p>\n</body>\n</html>\n```\n\n![Welcome to nginx!](nginx安装/1.png)","tags":["centos","nginx"],"categories":["centos","nginx"]},{"title":"Centos 7 Docker 安装","url":"/2019/01/24/Docker安装/","content":"\n### 操作预览：\n1.  安装一些基本依赖软件\n2.  为了使用 yum-config-manager 需要先安装一下 yum-utils\n3.  设置稳定版仓库\n4.  更新仓库（可选）\n5.  查看所有仓库中所有docker版本（可选）\n6.  正式下载安装\n7.  启动 (并开机启动)\n8.  检查是否安装成功\n\n////////////////////////////////////////////// \n前戏准备 \n//////////////////////////////////////////////\n\n\n###### 1、安装一些基本依赖软件\n```bash\n$ sudo yum install -y yum-utilsdevice-mapper-persistent-data lvm2\n```\n\n###### 2、为了使用 yum-config-manager 需要先安装一下这个 yum-utils\n```bash\n$ sudo yum -y install yum-utils\n```\n\n###### 3、设置稳定版仓库\n```bash\n$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n###### 4、更新仓库（可选）\n```bash\n$ sudo yum-config-manager --enable docker-ce-edge\n```\n\n////////////////////////////////////////////// \n正式开始 \n//////////////////////////////////////////////\n\n\n###### 5、查看所有仓库中所有docker版本（可选）\n```bash\n$ sudo yum list docker-ce --showduplicates | sort -r\n```\n\n###### 6、正式下载安装\n```bash\n$ sudo yum install docker-ce -y\n```\n\n###### 7、启动 (并开机启动)\n```bash\n$ sudo systemctl start docker\n$ sudo systemctl enable docker\n```\n\n###### 8、检查是否安装成功\n```bash\n$ docker -v\n```\n\n![Docker version 18.09.1](Docker安装/1.png)","tags":["centos","docker"],"categories":["docker"]},{"title":"Laravel Eloquent 入门","url":"/2019/01/20/laravel-Eloquent/","content":"\n# 一、数据建模\n\n创建一个名为 `Article` 的 Eloquent Model，Laravel 会自动将其与 Article 数据表关联。\n\n```php\n$ php artisan make:model Article\n```\n\n![\\app\\Article.php](laravel-Eloquent/1.png)\n\n<hr>\n\n# 二、tinker 命令行交互\n\n输入以下命令进入交互模式：\n\n```bash\n$ php artisan tinker\n```\n\n#### 示例 1 - Model与插入数据：\n\n```bash\n>>> $article = new App\\Article;\n=> App\\Article {#2909}\n\n>>> $article->title='My first Title';\n=> \"My first Title\"\n\n>>> $article->content='content'\n=> \"content\"\n\n>>> $article->published_at=Carbon\\Carbon::now();\n=> Carbon\\Carbon @1547995347 {#2913\n     date: 2019-01-20 14:42:27.721241 UTC (+00:00),\n   }\n\n>>> $article;\n=> App\\Article {#2909\n     title: \"My first Title\",\n     content: \"content\",\n     published_at: Carbon\\Carbon @1547995347 {#2913\n       date: 2019-01-20 14:42:27.721241 UTC (+00:00),\n     },\n   }\n\n>>> $article->save();\n=> true\n>>>\n```\n\n代码说明：\n- `$article = new App\\Article` ： 新建一个 Article Model；\n- `$article->title='My first Title'`：填充title字段；\n- `$article->content='content'`：填充content字段；\n- `$article->published_at=Carbon\\Carbon::now()`： 使用 `Carbon\\Carbon` 时间库来获取并设置当前时间；\n- `$article`：打印出当前的Model；\n- `$article->save()`：保存到数据库，如果返回true则表示成功；\n\n![Article Model](laravel-Eloquent/3.png)\n\n![Successful！！](laravel-Eloquent/2.png)\n\n\n也可以使用 `$article->toArray()` 打印出 Model 信息：\n```bash\n>>> $article->toArray()\n=> [\n     \"title\" => \"My first Title\",\n     \"content\" => \"content\",\n     \"published_at\" => Carbon\\Carbon @1547995347 {#2913\n       date: 2019-01-20 14:42:27.721241 UTC (+00:00),\n     },\n     \"updated_at\" => \"2019-01-20 14:43:05\",\n     \"created_at\" => \"2019-01-20 14:43:05\",\n     \"id\" => 1,\n   ]\n>>>\n```\n\n#### 示例 2 - 查找数据\n\n查找刚刚插入 `id` 为 **1** 的数据：\n\n```bash\n>>> $data = App\\Article::find(1);\n=> App\\Article {#2924\n     id: 1,\n     title: \"My first Title\",\n     content: \"content\",\n     published_at: \"2019-01-20 14:42:27\",\n     created_at: \"2019-01-20 14:43:05\",\n     updated_at: \"2019-01-20 14:43:05\",\n     introl: \"\",\n   }\n>>>\n```\n\n也可以使用 `App\\Article::all()` 方法无条件查找所有数据：\n\n```bash\n>>> $data=App\\Article::all()\n\n=> Illuminate\\Database\\Eloquent\\Collection {#2924\n     all: [\n       App\\Article {#2906\n         id: 1,\n         title: \"My first Title\",\n         content: \"content\",\n         published_at: \"2019-01-20 14:42:27\",\n         created_at: \"2019-01-20 14:43:05\",\n         updated_at: \"2019-01-20 14:43:05\",\n         introl: \"\",\n       },\n     ],\n   }\n>>>\n\n\n```\n\n#### 示例 3 - 更新数据\n\n和插入很相似，依然是使用 `save()` 方法：\n\n```bash\n>>> $data->title=\"Update\";\n=> \"Update\"\n\n>>> $data->save();\n=> true\n>>>\n```\n\n#### 示例 4 - where 查询\n\n```bash\n>>> $data=App\\Article::where('content', '=', 'content')->get()\n\n=> Illuminate\\Database\\Eloquent\\Collection {#2911\n     all: [\n       App\\Article {#2929\n         id: 1,\n         title: \"Update\",\n         content: \"content\",\n         published_at: \"2019-01-20 23:02:45\",\n         created_at: \"2019-01-20 14:43:05\",\n         updated_at: \"2019-01-20 15:02:45\",\n         introl: \"\",\n       },\n     ],\n   }\n>>>\n\n```\n\n`get()` 方法代表获取所有行，返回的是一个Collection数据类型。可以理解为一个加强版的数组。\n\n通常我们只想返回一条数据，那么可以使用 `first()` 方法，它只会直接返回一个对象：\n\n```bash\n>>> $data=App\\Article::where('content', '=', 'content')->first()\n\n=> App\\Article {#2910\n     id: 1,\n     title: \"Update\",\n     content: \"content\",\n     published_at: \"2019-01-20 23:02:45\",\n     created_at: \"2019-01-20 14:43:05\",\n     updated_at: \"2019-01-20 15:02:45\",\n     introl: \"\",\n   }\n\n>>> $data->title\n=> \"Update\"\n```\n\n#### 示例 5 - `create()` / `update()` \n\n使用 `App\\Article::create([...])` 和 `$model->udate([...])` 可以更便捷的创建和更新数据。\n\n先来 `\\app\\Article.php` 中添加代码，设置字段允许被填充：\n\n```php\n<?php\n\nnamespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Article extends Model\n{\n    protected $fillable = ['title', 'content', 'published_at'];\n}\n```\n\n**必须重新进入命令行交互！！**\n**必须重新进入命令行交互！！**\n**必须重新进入命令行交互！！**\n\n使用 `App\\Article::create([...])` 来创建数据：\n\n```bash\n>>> $article=App\\Article::create(['title'=>'Second Title', 'content'=>'Second Content', 'published_at'=>Carbon\\Carbon::now() ]);\n\n=> App\\Article {#2913\n     title: \"Second Title\",\n     content: \"Second Content\",\n     published_at: Carbon\\Carbon @1547998078 {#2923\n       date: 2019-01-20 15:27:58.713977 UTC (+00:00),\n     },\n     updated_at: \"2019-01-20 15:27:58\",\n     created_at: \"2019-01-20 15:27:58\",\n     id: 2,\n   }\n>>>\n\n```\n\n使用 `$model->udate([...])` 来更新数据：\n\n```bash\n>>> $article->update(['title'=>'Change Title']);\n=> true\n```\n","tags":["php","laravel"],"categories":["php","laravel"]},{"title":"Laravel Mysql 数据库配置 与 Migration 基础","url":"/2019/01/20/laravel-migration/","content":"\n# 一、MySql 数据库配置\n\n先来配置一下数据库，打开 Laravel 的环境配置 `\\.env` 文件，简单配置你的数据库信息：\n\n```\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=laravel\nDB_USERNAME=root\nDB_PASSWORD=root\n```\n\n再打开数据库配置文件 `\\config\\database.php`，检查当前的 Mysql 数据库配置：\n\n```php\n<?php\n\n'default' => env('DB_CONNECTION', 'mysql'),\n\n'mysql' => [\n    'driver' => 'mysql',\n    'host' => env('DB_HOST'),\n    'port' => env('DB_PORT'),\n    'database' => env('DB_DATABASE'),\n    'username' => env('DB_USERNAME'),\n    'password' => env('DB_PASSWORD'),\n    'prefix' => '',\n],\n\n// ... otherthing\n\n```\n\n<hr>\n\n# 二、migrate 初体验\n\nLaravel 最强大工具之一：**migration**\n\n如果对 `migration` 的概念不清晰，可以简单理解为数据库的版本控制工具。有了它我们就可以对数据库进行方便的管理和愉快地开发了。\n\n\n找到 `\\database\\migrations\\`，可以看到Laravel默认帮我们准备了两个 migrations 示例文件。\n\n![migrations 示例文件](laravel-migration/1.png)\n\n我们就来学习和使用一下 `2014_10_12_000000_create_users_table.php` 文件：\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass CreateUsersTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('users', function (Blueprint $table) {\n            $table->increments('id');\n            $table->string('name');\n            $table->string('email')->unique();\n            $table->timestamp('email_verified_at')->nullable();\n            $table->string('password');\n            $table->rememberToken();\n            $table->timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::dropIfExists('users');\n    }\n}\n\n```\n\n代码说明：\n- up： 负责创建一个 `users` 表；\n- down： 为了避免重复新建，负责删除 `users` 表，**但这也说明每次执行都会清空该表的数据**；\n\n\n\n```bash\n$ php artisan migrate\n```\n\n![successfully！！！](laravel-migration/2.png)\n\n![Navicat for MySql](laravel-migration/3.png)\n\n<hr>\n\n# 三、创建 migration 文件\n\n刚刚我们使用了 Laravel 示例的 migration 文件，现在我们新建一个自己的文章表 `articles`，依然可以通过 `artisan` 命令来创建：\n\n```bash\n$ php artisan make:migration create-articles_table --create=articles\n```\n\n![Created Migration successfully](laravel-migration/4.png)\n\n![2019_01_20_042528_create-articles_table](laravel-migration/5.png)\n\n自动生成文件 `\\database\\migrations\\2019_01_20_042528_create-articles_table.php `，代码如下：\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass CreateArticlesTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('articles', function (Blueprint $table) {\n            $table->increments('id');\n            $table->timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::dropIfExists('articles');\n    }\n}\n\n```\n\n其中 `$table->timestamps();` 建议保留，Laravel 会自动创建并维护 `created_at` 和 `updated_at` 字段。\n\n我们试着添加一些基本字段，代码如下：\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass CreateArticlesTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('articles', function (Blueprint $table) {\n            $table->increments('id');\n            $table->string('title');\n            $table->text('content');\n            $table->timestamp('published_at');\n            $table->timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::dropIfExists('articles');\n    }\n}\n\n```\n\n再次执行 migrate 命令 \n\n```bash\nphp artisan migrate\n```\n\n![New DataTable articles](laravel-migration/6.png)\n\n<hr>\n\n# 四、添加字段\n\n假设我们现在需要为 `articles` 表添加一个简介字段 `intro`。\n\n```bash\n$ php artisan make:migration add_intro_column_to_articles --table=articles\n```\n\n`\\database\\migrations\\2019_01_20_060259_add_intro_column_to_articles.php` 默认代码如下：\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddIntroColumnToArticles extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table('articles', function (Blueprint $table) {\n            //\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table('articles', function (Blueprint $table) {\n            //\n        });\n    }\n}\n```\n\n添加代码：\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass AddIntroColumnToArticles extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::table('articles', function (Blueprint $table) {\n            $table->string('introl');\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table('articles', function (Blueprint $table) {\n            $table->dropColumn('introl');\n        });\n    }\n}\n```\n\n又又又执行命令： `$ php artisan migrate`\n\n刷新数据表 `articles` ，成功添加了 `introl` 字段：\n\n![Add Column introl](laravel-migration/7.png)\n\n事实上，如果真的要执行 `$table->dropColumn` 需要依赖一个第三方包，这里安装一下吧：\n\n```bash\n$ composer require doctrine/dbal\n```","tags":["php","laravel"],"categories":["php","laravel"]},{"title":"Laravel 入门示例（三）：常用的blade语法","url":"/2019/01/20/laravel-demo3/","content":"\n# @yield 语法\n\n中文理解为区域，在母版页（layouts）中会使用。类似 Vue 中的 `<slot name='content'>` 标签。 \n\n新建 **\\resources\\views\\layouts\\app.blade.php**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js\"></script>\n    <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/twitter-bootstrap/3.3.6/css/bootstrap.min.css\">\n    <script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.3.6/js/bootstrap.min.js\"></script>\n</head>\n<body>\n    @yield('content')\n</body>\n</html>\n```\n\n\\resources\\views\\sites\\about.blade.php\n\n```html\n@extends('layouts/app')\n@section('content')\n    <h1>about me {{$first}} {{$last}}</h1>\n@stop\n```\n\n### 语法说明：\n- **@extends**：继承 `\\resources\\views\\layouts\\app.blade.php` 模板；\n- **@section**：将内容填充到 `@yield('content')` 中；\n- **@stop**：通常一个 `@section` 对应一个 `$stop`；\n\n可以发现 **bootstrap** 的样式起到效果了：\n\n![](laravel-demo3/1.png)\n\n<hr>\n\n# 特定的页面加载特定的js文件\n\n其实非常简单，只需要在 `layouts` 中新增多个@yield，在特定的页面选择性填充这个区域即可。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js\"></script>\n    <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/twitter-bootstrap/3.3.6/css/bootstrap.min.css\">\n    <script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.3.6/js/bootstrap.min.js\"></script>\n</head>\n<body>\n    @yield('content')\n    @yield('footer')\n</body>\n</html>\n```\n\n```html\n@extends('layouts/app')\n@section('content')\n    <h1>about me {{$first}} {{$last}}</h1>\n@stop\n\n@section('footer')\n    <script>alert('yesh！！')</script>\n@stop\n```\n\n![](laravel-demo3/2.png)\n\n<hr>\n\n# @if 语法\n```html\n@extends('layouts/app')\n@section('content')\n    @if ($first == \"Zhou\")\n        <h1>about me {{$first}} {{$last}}</h1>\n    @else\n        <h2>nothing</h2>\n    @endif\n@stop\n```\n\n<hr>\n\n# @foreach 语法\n\n先在控制器中导出数组 \n\n\\app\\Http\\Controllers\\SitesController.php\n\n```php\npublic function about () {\n    $people = ['Taylor Otwell', 'Jeffray Way', 'Happy Petter'];\n    return view('sites/about', compact('people'));\n}\n```\n\n通常 @foreach 会结合 @if 使用，否则会出现多余的html标签的情况\n\n```html\n@extends('layouts/app')\n@section('content')\n    @if (count($people) > 0)\n        <ul>\n            @foreach ($people as $p)\n                <li>{{ $p }}</li>\n            @endforeach\n        </ul>\n    @endif\n@stop\n```\n\n![](laravel-demo3/3.png)","tags":["php","laravel"],"categories":["php","laravel"]},{"title":"Laravel 入门示例（二）：初识控制器与视图","url":"/2019/01/19/laravel-demo2/","content":"\n1、新建 **resources\\views\\sites\\about.blade.php**\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>about me</h1>\n</body>\n</html>\n```\n\n2、新增 **about** 路由\n\n\\routes\\web.php\n\n```php\n<?php\n\nRoute::get('/', 'SitesController@index');\n\nRoute::get('/about', 'SitesController@about');\n```\n\n3、控制器新增 **about** 方法\n\n\\app\\Http\\Controllers\\SitesController.php\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass SitesController extends Controller\n{\n    // Route::get('/', 'SitesController@index');\n    public function index () {\n        return view('welcome');\n    }\n\n    // Route::get('/about', 'SitesController@about');\n    public function about () {\n        return view('sites.about');\n    }\n}\n```\n\n要访问 **resources/views/sites/about.blade.php** 页面，可以有两种方式：\n- return view('sites/about');\n- return view('sites.about'); **（推荐）**\n\n访问 [http://127.0.0.1:8000/about](http://127.0.0.1:8000/about)，效果如图所示：\n\n![](laravel-demo2/1.png)\n\n<hr>\n\n# 向视图传递变量\n\n1、 **with()** 与 原生渲染\n\n```php\npublic function about () {\n    $name = 'Lee';\n    return view('sites/about')->with('name', $name);\n}\n```\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>about me <?= $name; ?></h1>\n</body>\n</html>\n```\n\n2、 使用 **blade** 模板引擎语法来渲染\n\n我们注意到视图文件都是 **.blade.php** 文件，所以理所应当使用更简洁的模板渲染语法。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>about me {{ $name }}</h1>\n</body>\n</html>\n```\n\n**{!! $name !!}** 的语法可以用来解析html。譬如 $name 的值为 `<span style='color: red'> Lee </span>` 时，但要小心xss 攻击！\n\n![](laravel-demo2/2.png)\n\n\n3、使用数组传递多个变量\n\n```php\npublic function about () {\n    return view('sites/about')->with([\n        'first' => 'Lee',\n        'last' => 'Mp'\n    ]);\n}\n```\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>about me {{$first}} {{$last}}</h1>\n</body>\n</html>\n```\n\n4、类 yii 的传递方式\n```php\npublic function about () {\n    $data = [];\n    $data['first'] = 'Lee';\n    $data['last'] = 'Mp';\n    return view('sites/about', $data);\n}\n```\n\n5、 **compact** 方式**（推荐）**\n```php\npublic function about () {\n    $first = 'Lee';\n    $last = 'Mp';\n    return view('sites/about', compact('first', 'last'));\n}\n```\n\n![](laravel-demo2/3.png)","tags":["php","laravel"],"categories":["php","laravel"]},{"title":"Laravel 入门示例（一）：初识控制器与路由","url":"/2019/01/19/laravel-demo1/","content":"\n1、先用 **artisan** 命令新建一个 **Controller**，命名为 **SitesController**\n\n```bash\n$ php artisan make:controller SitesController\n```\n\n生成的文件在目录： **\\app\\Http\\Controllers\\SitesController.php**，添加内容如下：\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass SitesController extends Controller\n{\n    // Route::get('/', 'SitesController@index');\n    public function index () {\n    \treturn view('welcome');\n    }\n}\n\n\n```\n\n这里的 welcome 页面是在：**\\resources\\views\\welcome.blade.php**\n\n2、打开 **\\routes\\web.php**，修改内容为：\n\n```php\n<?php\n\n// Route::get('/', function () {\n//     return view('welcome');\n// });\n\nRoute::get('/', 'SitesController@index');\n```\n\n刷新页面，一切如故。 ","tags":["php","laravel"],"categories":["php","laravel"]},{"title":"laravel 安装与启动","url":"/2019/01/19/laravel安装与启动/","content":"\n## 1、使用 composer 安装 laravel\n\n[https://packagist.org/packages/laravel/laravel](https://packagist.org/packages/laravel/laravel)\n\n```bash\n$ composer create-project laravel/laravel laravel5\n```\n\n&#8195;&#8195;\n\n## 2、启动 laravel\n\n##### 方式一：php 内置服务器\n\n指定 public 文件夹即可\n\n```bash\n$ php -S localhost:8000 -t public\n```\n\n##### 方式二：使用laravel提供的命令行工具artisan\n\n```bash\n$ php artisan serve\n```\n\n![](laravel-start/2.png)\n\n预览 [http://localhost:8000](http://localhost:8000) ，效果如下：\n\n![](laravel-start/1.png)","tags":["php","laravel"],"categories":["php","laravel"]},{"title":"hexo插入本地图片","url":"/2019/01/19/hexo插入本地图片/","content":"\n安装 [hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)\n\n```bash\n$ cnpm install hexo-asset-image --save\n```\n\n**_config.yml** 开启 **post_asset_folder: true**\n\n```yaml\npost_asset_folder: true\n```\n\n完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。\n\n![](hexo插入本地图片/3.png)\n\n只需要使用该语句即可插入图片\n\n```\n![](test-img/1.png)\n```","tags":["hexo"],"categories":["hexo"]},{"title":"composer疑难杂症","url":"/2019/01/19/composer疑难杂症/","content":"\n## The openssl extension is required for SSL/TLS protection\n\n![](composer疑难杂症/1.png)\n\n解决方法：在php.ini文件中打开php_openssl扩展 \n\n```\nextension=php_openssl.dll\n```","tags":["php","cpmposer"],"categories":["cpmposer"]}]